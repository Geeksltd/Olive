using System.Threading.Tasks;
using Olive.Services.Integration;

namespace Olive.Services.Testing
{
    // Note: This is a service implementation example.
    // MyService can be replaced by a proper name depending on your project's requirements.


    /// <summary>
    /// This simple class will not have any implementation body. It's used to invoke the service.
    /// </summary>
    class MyService : IntegrationService<MyServiceRequest, MyServiceResponse> { }

    /// <summary>
    /// A basic C# class to contain all parameters which are logically part of your application.
    /// Do not add properties which are used only to establish the pipelines such as constant security keys, access tokens, etc.
    /// This class should be minimal and only represent what has a meaning in yoru application's domain for the purpose of integration.
    /// </summary>
    class MyServiceRequest
    {
        public string Param1, Param2;
    }

    /// <summary>
    /// Same as MyServiceRequest, it should only have data fields that are relevant to the domain of your application.
    /// Keep it pure and simple. It can have a full hierarchy such as List classes, nested objects, etc.
    /// </summary>
    class MyServiceResponse
    {
        public string Ourcome1, Ourcome2;
    }

    namespace My.VSProject
    {
        /// <summary>
        /// The actual service implementation. Keep it in a separate DLL (project).               
        /// Your Model project should not reference this DLL, but your website project should.
        /// This dll should reference your Model dll.
        /// It should be self sufficient class that can work simply from ServiceRequest and web.config data.
        /// </summary>
        class MyServiceImplementor : IServiceImplementor<MyServiceRequest, MyServiceResponse>
        {
            /// <summary>
            /// In this method, write the actual implementation. Make calls to the external web service, Http, etc.
            /// You can use any set of implementation classes for this, including those typically generated by WSDL utilities.
            /// You can make several calls to the external service, establish security, read from web.config, etc.
            /// At the end of the process, the final relevant information should be written into an instance of MyServiceResponse and returned.
            /// </summary>
            public MyServiceResponse GetResponse(MyServiceRequest request)
            {
                // Dirty work goes here.
                // ...
                return new MyServiceResponse { Ourcome1 = "sample", Ourcome2 = "sample" };
            }
        }
    }

    class Website
    {
        public async Task Global_ASAX()
        {
            // The actual service implementation will be registerd here once for live use (non-test mode).
            // Throughout the development period when the application is in TDD mode, this service is essentially not registered, so
            // there is no dependency on the external service.

            // Perhaps only once when the ServiceImplementation is created during development cycle,
            // you can remove the condition to test it once or twice.
            if (WebTestManager.IsTddExecutionMode() == false)
            {
                MyService.RegisterImplementor<My.VSProject.MyServiceImplementor>();

                // Optional: Add an Automated Task to call the following.
                // It will frequently process all outstanding items in the queue.
                // Mainly relevant for multi-try situations in live operations. Avoid unless necessary.
                await IntegrationManager.ProcessOutstandingItems();
            }
            else
            {
                // Note: In case you need to provide a Mock implementation for the service, instead of manually injecting the responses
                // through sanity, you can create a class that fakes responses to requests and inject it here:
                // e.g: MyService.Register<My.VSProject.MyServiceMockImplementation>();
            }
        }
    }

    class Model
    {
        internal void SomeBusinessLogicMethod()
        {
            // In the consumer classes (mostly in your Model project), all requests to the integration services will be via the following method.
            // Note: The following method will serialize the request and insert it in the IntegrationQueueItem table.
            // It will then wait for the response to be provided.

            // In TDD mode, the ServiceImplementation will not have been registered, and therefore this call will wait indefinitely for a response.
            // In practice, whilst this method is waiting for the response, the idea is that you manually go to the Database and inject the response
            // in the Queue. As soon as the response is provided, the waiting method will then pick the result and proceed.

            // In Sanity there is a command called "$check integartion queue" used to manually inject the response.

            var result = MyService.Request(new MyServiceRequest { Param1 = "1", Param2 = "X" });
        }
    }

    class UnitTest
    {
        public Task UnitTest_For_Business_Logic_Layer()
        {
            // When the service consumer unit (business logic layer) is invoked, it will in turn insert its IntegrationQueueItem and wait for its response.
            // So instead of directly calling the method in your Unit Test, you should invoke that in a Task.
            var app = new Model();
            var task = new System.Threading.Tasks.Task(app.SomeBusinessLogicMethod);
            task.Start();

            // At this stage the logic unit is waiting for the response. So here we just inject a response, so the unit will continue then.
            var assumedResponse = new MyServiceResponse { Ourcome1 = "Something", Ourcome2 = "anything" };
            return MyService.InjectResponse(assumedResponse);

            // At this stage, the MyService.Request() called inside the logic unit, will come out of freezing and return the injected
            // response to the consumer unit.


            // Note: This way, the dependency to the external service is bypassed by manually injecting the response.
        }
    }
}